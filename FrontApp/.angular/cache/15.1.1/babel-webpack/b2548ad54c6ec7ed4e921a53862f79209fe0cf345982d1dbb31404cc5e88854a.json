{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOCUMENT } from '@angular/common';\nimport { InjectionToken, Inject, Injectable, ElementRef, Renderer2, Directive, forwardRef, HostListener, Input, Pipe, NgModule } from '@angular/core';\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nimport * as Éµngcc0 from '@angular/core';\nconst config = new InjectionToken('config');\n/** @type {?} */\nconst NEW_CONFIG = new InjectionToken('NEW_CONFIG');\n/** @type {?} */\nconst INITIAL_CONFIG = new InjectionToken('INITIAL_CONFIG');\n/** @type {?} */\nconst initialConfig = {\n  sufix: '',\n  prefix: '',\n  clearIfNotMatch: false,\n  showTemplate: false,\n  showMaskTyped: false,\n  dropSpecialCharacters: true,\n  shownMaskExpression: '',\n  specialCharacters: ['-', '/', '(', ')', '.', ':', ' ', '+', ',', '@', '[', ']', '\\\"', '\\''],\n  patterns: {\n    '0': {\n      pattern: new RegExp('\\\\d')\n    },\n    '9': {\n      pattern: new RegExp('\\\\d'),\n      optional: true\n    },\n    'A': {\n      pattern: new RegExp('\\[a-zA-Z0-9\\]')\n    },\n    'S': {\n      pattern: new RegExp('\\[a-zA-Z\\]')\n    },\n    'd': {\n      pattern: new RegExp('\\\\d')\n    },\n    'm': {\n      pattern: new RegExp('\\\\d')\n    },\n    'H': {\n      pattern: new RegExp('\\\\d')\n    },\n    'h': {\n      pattern: new RegExp('\\\\d')\n    },\n    's': {\n      pattern: new RegExp('\\\\d')\n    }\n  }\n};\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet MaskApplierService = /*#__PURE__*/(() => {\n  class MaskApplierService {\n    /**\n     * @param {?} _config\n     */\n    constructor(_config) {\n      this._config = _config;\n      this.maskExpression = '';\n      this.shownMaskExpression = '';\n      this.separator =\n      /**\n      * @param {?} str\n      * @param {?} char\n      * @param {?} decimalChar\n      * @param {?} precision\n      * @return {?}\n      */\n      (str, char, decimalChar, precision) => {\n        str += '';\n        /** @type {?} */\n        const x = str.split(decimalChar);\n        /** @type {?} */\n        const decimals = x.length > 1 ? `${decimalChar}${x[1]}` : '';\n        /** @type {?} */\n        let res = x[0];\n        /** @type {?} */\n        const rgx = /(\\d+)(\\d{3})/;\n        while (rgx.test(res)) {\n          res = res.replace(rgx, '$1' + char + '$2');\n        }\n        if (precision === undefined) {\n          return res + decimals;\n        } else if (precision === 0) {\n          return res;\n        }\n        return res + decimals.substr(0, precision + 1);\n      };\n      this.percentage =\n      /**\n      * @param {?} str\n      * @return {?}\n      */\n      str => {\n        return Number(str) >= 0 && Number(str) <= 100;\n      };\n      this.getPrecision =\n      /**\n      * @param {?} maskExpression\n      * @return {?}\n      */\n      maskExpression => {\n        /** @type {?} */\n        const x = maskExpression.split('.');\n        if (x.length > 1) {\n          return Number(x[x.length - 1]);\n        }\n        return Infinity;\n      };\n      this.checkInputPrecision =\n      /**\n      * @param {?} inputValue\n      * @param {?} precision\n      * @param {?} decimalMarker\n      * @return {?}\n      */\n      (inputValue, precision, decimalMarker) => {\n        if (precision < Infinity) {\n          /** @type {?} */\n          let precisionRegEx;\n          if (decimalMarker === '.') {\n            precisionRegEx = new RegExp(`\\\\.\\\\d{${precision}}.*$`);\n          } else {\n            precisionRegEx = new RegExp(`,\\\\d{${precision}}.*$`);\n          }\n          /** @type {?} */\n          const precisionMatch = inputValue.match(precisionRegEx);\n          if (precisionMatch && precisionMatch[0].length - 1 > precision) {\n            inputValue = inputValue.substring(0, inputValue.length - 1);\n          } else if (precision === 0 && inputValue.endsWith(decimalMarker)) {\n            inputValue = inputValue.substring(0, inputValue.length - 1);\n          }\n        }\n        return inputValue;\n      };\n      this._shift = new Set();\n      this.maskSpecialCharacters = /** @type {?} */this._config.specialCharacters;\n      this.maskAvailablePatterns = this._config.patterns;\n      this.clearIfNotMatch = this._config.clearIfNotMatch;\n      this.dropSpecialCharacters = this._config.dropSpecialCharacters;\n      this.maskSpecialCharacters = /** @type {?} */this._config.specialCharacters;\n      this.maskAvailablePatterns = this._config.patterns;\n      this.prefix = this._config.prefix;\n      this.sufix = this._config.sufix;\n    }\n    // tslint:disable-next-line:no-any\n    /**\n     * @param {?} inputValue\n     * @param {?} maskAndPattern\n     * @return {?}\n     */\n    applyMaskWithPattern(inputValue, maskAndPattern) {\n      const [mask, customPattern] = maskAndPattern;\n      this.customPattern = customPattern;\n      return this.applyMask(inputValue, mask);\n    }\n    /**\n     * @param {?} inputValue\n     * @param {?} maskExpression\n     * @param {?=} position\n     * @param {?=} cb\n     * @return {?}\n     */\n    applyMask(inputValue, maskExpression, position = 0, cb =\n    /**\n    * @return {?}\n    */\n    () => {}) {\n      if (inputValue === undefined || inputValue === null || maskExpression === undefined) {\n        return '';\n      }\n      /** @type {?} */\n      let cursor = 0;\n      /** @type {?} */\n      let result = ``;\n      /** @type {?} */\n      let multi = false;\n      if (inputValue.slice(0, this.prefix.length) === this.prefix) {\n        inputValue = inputValue.slice(this.prefix.length, inputValue.length);\n      }\n      /** @type {?} */\n      const inputArray = inputValue.toString().split('');\n      if (maskExpression === 'percent') {\n        if (inputValue.match('[a-z]|[A-Z]') || inputValue.match(/[-!$%^&*()_+|~=`{}\\[\\]:\";'<>?,\\/]/)) {\n          inputValue = inputValue.substring(0, inputValue.length - 1);\n        }\n        if (this.percentage(inputValue)) {\n          result = inputValue;\n        } else {\n          result = inputValue.substring(0, inputValue.length - 1);\n        }\n      } else if (maskExpression === 'separator' || maskExpression === 'dot_separator' || maskExpression.startsWith('dot_separator') || maskExpression === 'coma_separator' || maskExpression.startsWith('coma_separator')) {\n        if (inputValue.match('[a-z]|[A-Z]') || inputValue.match(/[@#!$%^&*()_+|~=`{}\\[\\]:\";<>?\\/]/)) {\n          inputValue = inputValue.substring(0, inputValue.length - 1);\n        }\n        /** @type {?} */\n        const precision = this.getPrecision(maskExpression);\n        /** @type {?} */\n        let strForSep;\n        if (maskExpression === 'separator') {\n          if (inputValue.includes(',') && inputValue.endsWith(',') && inputValue.indexOf(',') !== inputValue.lastIndexOf(',')) {\n            inputValue = inputValue.substring(0, inputValue.length - 1);\n          }\n          if (inputValue.match('[a-z]|[A-Z]') || inputValue.match(/[@#!$%^&*()_+|~=`{}\\[\\]:.\";<>?\\/]/)) {\n            inputValue = inputValue.substring(0, inputValue.length - 1);\n          }\n          strForSep = inputValue.replace(/\\s/g, '');\n          result = this.separator(strForSep, ' ', '.', precision);\n        } else if (maskExpression === 'dot_separator' || maskExpression.startsWith('dot_separator')) {\n          if (inputValue.match('[a-z]|[A-Z]') || inputValue.match(/[@#!$%^&*()_+|~=`{}\\[\\]:\\s\";<>?\\/]/)) {\n            inputValue = inputValue.substring(0, inputValue.length - 1);\n          }\n          inputValue = this.checkInputPrecision(inputValue, precision, ',');\n          strForSep = inputValue.replace(/\\./g, '');\n          result = this.separator(strForSep, '.', ',', precision);\n        } else if (maskExpression === 'coma_separator' || maskExpression.startsWith('coma_separator')) {\n          inputValue = this.checkInputPrecision(inputValue, precision, '.');\n          strForSep = inputValue.replace(/\\,/g, '');\n          result = this.separator(strForSep, ',', '.', precision);\n        }\n        position = result.length + 1;\n        cursor = position;\n        /** @type {?} */\n        const shiftStep = /\\*|\\?/g.test(maskExpression.slice(0, cursor)) ? inputArray.length : cursor;\n        this._shift.add(shiftStep + this.prefix.length || 0);\n      } else {\n        // tslint:disable-next-line\n        for (let i = 0, inputSymbol = inputArray[0]; i < inputArray.length; i++, inputSymbol = inputArray[i]) {\n          if (cursor === maskExpression.length) {\n            break;\n          }\n          if (this._checkSymbolMask(inputSymbol, maskExpression[cursor]) && maskExpression[cursor + 1] === '?') {\n            result += inputSymbol;\n            cursor += 2;\n          } else if (maskExpression[cursor + 1] === '*' && multi && this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2])) {\n            result += inputSymbol;\n            cursor += 3;\n            multi = false;\n          } else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor]) && maskExpression[cursor + 1] === '*') {\n            result += inputSymbol;\n            multi = true;\n          } else if (maskExpression[cursor + 1] === '?' && this._checkSymbolMask(inputSymbol, maskExpression[cursor + 2])) {\n            result += inputSymbol;\n            cursor += 3;\n          } else if (this._checkSymbolMask(inputSymbol, maskExpression[cursor])) {\n            if (maskExpression[cursor] === 'H') {\n              if (Number(inputSymbol) > 2) {\n                result += 0;\n                cursor += 1;\n                /** @type {?} */\n                const shiftStep = /\\*|\\?/g.test(maskExpression.slice(0, cursor)) ? inputArray.length : cursor;\n                this._shift.add(shiftStep + this.prefix.length || 0);\n                i--;\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 'h') {\n              if (result === '2' && Number(inputSymbol) > 3) {\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 'm') {\n              if (Number(inputSymbol) > 5) {\n                result += 0;\n                cursor += 1;\n                /** @type {?} */\n                const shiftStep = /\\*|\\?/g.test(maskExpression.slice(0, cursor)) ? inputArray.length : cursor;\n                this._shift.add(shiftStep + this.prefix.length || 0);\n                i--;\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 's') {\n              if (Number(inputSymbol) > 5) {\n                result += 0;\n                cursor += 1;\n                /** @type {?} */\n                const shiftStep = /\\*|\\?/g.test(maskExpression.slice(0, cursor)) ? inputArray.length : cursor;\n                this._shift.add(shiftStep + this.prefix.length || 0);\n                i--;\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 'd') {\n              if (Number(inputSymbol) > 3) {\n                result += 0;\n                cursor += 1;\n                /** @type {?} */\n                const shiftStep = /\\*|\\?/g.test(maskExpression.slice(0, cursor)) ? inputArray.length : cursor;\n                this._shift.add(shiftStep + this.prefix.length || 0);\n                i--;\n                continue;\n              }\n            }\n            if (maskExpression[cursor - 1] === 'd') {\n              if (Number(inputValue.slice(cursor - 1, cursor + 1)) > 31) {\n                continue;\n              }\n            }\n            if (maskExpression[cursor] === 'm') {\n              if (Number(inputSymbol) > 1) {\n                result += 0;\n                cursor += 1;\n                /** @type {?} */\n                const shiftStep = /\\*|\\?/g.test(maskExpression.slice(0, cursor)) ? inputArray.length : cursor;\n                this._shift.add(shiftStep + this.prefix.length || 0);\n                i--;\n                continue;\n              }\n            }\n            if (maskExpression[cursor - 1] === 'm') {\n              if (Number(inputValue.slice(cursor - 1, cursor + 1)) > 12) {\n                continue;\n              }\n            }\n            result += inputSymbol;\n            cursor++;\n          } else if (this.maskSpecialCharacters.indexOf(maskExpression[cursor]) !== -1) {\n            result += maskExpression[cursor];\n            cursor++;\n            /** @type {?} */\n            const shiftStep = /\\*|\\?/g.test(maskExpression.slice(0, cursor)) ? inputArray.length : cursor;\n            this._shift.add(shiftStep + this.prefix.length || 0);\n            i--;\n          } else if (this.maskSpecialCharacters.indexOf(inputSymbol) > -1 && this.maskAvailablePatterns[maskExpression[cursor]] && this.maskAvailablePatterns[maskExpression[cursor]].optional) {\n            cursor++;\n            i--;\n          } else if (this.maskExpression[cursor + 1] === '*' && this._findSpecialChar(this.maskExpression[cursor + 2]) && this._findSpecialChar(inputSymbol) === this.maskExpression[cursor + 2] && multi) {\n            cursor += 3;\n            result += inputSymbol;\n          }\n        }\n      }\n      if (result.length + 1 === maskExpression.length && this.maskSpecialCharacters.indexOf(maskExpression[maskExpression.length - 1]) !== -1) {\n        result += maskExpression[maskExpression.length - 1];\n      }\n      /** @type {?} */\n      let shift = 1;\n      /** @type {?} */\n      let newPosition = position + 1;\n      while (this._shift.has(newPosition)) {\n        shift++;\n        newPosition++;\n      }\n      cb(this._shift.has(position) ? shift : 0);\n      /** @type {?} */\n      let res = `${this.prefix}${result}`;\n      res = this.sufix ? `${this.prefix}${result}${this.sufix}` : `${this.prefix}${result}`;\n      if (result.length === 0) {\n        res = `${this.prefix}${result}`;\n      }\n      return res;\n    }\n    /**\n     * @param {?} inputSymbol\n     * @return {?}\n     */\n    _findSpecialChar(inputSymbol) {\n      /** @type {?} */\n      const symbol = this.maskSpecialCharacters.find(\n      /**\n      * @param {?} val\n      * @return {?}\n      */\n      val => val === inputSymbol);\n      return symbol;\n    }\n    /**\n     * @private\n     * @param {?} inputSymbol\n     * @param {?} maskSymbol\n     * @return {?}\n     */\n    _checkSymbolMask(inputSymbol, maskSymbol) {\n      this.maskAvailablePatterns = this.customPattern ? this.customPattern : this.maskAvailablePatterns;\n      return this.maskAvailablePatterns[maskSymbol] && this.maskAvailablePatterns[maskSymbol].pattern && this.maskAvailablePatterns[maskSymbol].pattern.test(inputSymbol);\n    }\n  }\n  MaskApplierService.Éµfac = function MaskApplierService_Factory(t) {\n    return new (t || MaskApplierService)(Éµngcc0.ÉµÉµinject(config));\n  };\n  MaskApplierService.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: MaskApplierService,\n    factory: MaskApplierService.Éµfac\n  });\n  /** @nocollapse */\n  return MaskApplierService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet MaskService = /*#__PURE__*/(() => {\n  class MaskService extends MaskApplierService {\n    /**\n     * @param {?} document\n     * @param {?} _config\n     * @param {?} _elementRef\n     * @param {?} _renderer\n     */\n    constructor(document, _config, _elementRef, _renderer) {\n      super(_config);\n      this.document = document;\n      this._config = _config;\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this.maskExpression = '';\n      this.isNumberValue = false;\n      this.showMaskTyped = false;\n      this.maskIsShown = '';\n      // tslint:disable-next-line\n      this.onChange =\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => {};\n      this.onTouch =\n      /**\n      * @return {?}\n      */\n      () => {};\n      this._formElement = this._elementRef.nativeElement;\n    }\n    /**\n     * @param {?} inputValue\n     * @param {?} maskExpression\n     * @param {?=} position\n     * @param {?=} cb\n     * @return {?}\n     */\n    applyMask(inputValue, maskExpression, position = 0, cb =\n    /**\n    * @return {?}\n    */\n    () => {}) {\n      this.maskIsShown = this.showMaskTyped ? this.showMaskInInput() : '';\n      if (!inputValue && this.showMaskTyped) {\n        return this.prefix + this.maskIsShown;\n      }\n      /** @type {?} */\n      const result = super.applyMask(inputValue, maskExpression, position, cb);\n      if (this.maskExpression === 'dot_separator.2' && this.dropSpecialCharacters === true) {\n        this.maskSpecialCharacters = this.maskSpecialCharacters.filter(\n        /**\n        * @param {?} item\n        * @return {?}\n        */\n        item => item !== ',');\n      }\n      if (this.maskExpression === 'coma_separator.2' && this.dropSpecialCharacters === true) {\n        this.maskSpecialCharacters = this.maskSpecialCharacters.filter(\n        /**\n        * @param {?} item\n        * @return {?}\n        */\n        item => item !== '.');\n      }\n      Array.isArray(this.dropSpecialCharacters) ? this.onChange(this._removeMask(this._removeSufix(this._removePrefix(result)), this.dropSpecialCharacters)) : this.dropSpecialCharacters === true ? this.onChange(this.isNumberValue ? Number(this._removeMask(this._removeSufix(this._removePrefix(result)), this.maskSpecialCharacters)) : this._removeMask(this._removeSufix(this._removePrefix(result)), this.maskSpecialCharacters)) : this.onChange(this._removeSufix(this._removePrefix(result)));\n      /** @type {?} */\n      let ifMaskIsShown = '';\n      if (!this.showMaskTyped) {\n        return result;\n      }\n      /** @type {?} */\n      const resLen = result.length;\n      /** @type {?} */\n      const prefNmask = this.prefix + this.maskIsShown;\n      ifMaskIsShown = prefNmask.slice(resLen);\n      return result + ifMaskIsShown;\n    }\n    /**\n     * @param {?=} position\n     * @param {?=} cb\n     * @return {?}\n     */\n    applyValueChanges(position = 0, cb =\n    /**\n    * @return {?}\n    */\n    () => {}) {\n      /** @type {?} */\n      const maskedInput = this.applyMask(this._formElement.value, this.maskExpression, position, cb);\n      this._formElement.value = maskedInput;\n      if (this._formElement === this.document.activeElement) {\n        return;\n      }\n      this.clearIfNotMatchFn();\n    }\n    /**\n     * @return {?}\n     */\n    showMaskInInput() {\n      if (this.showMaskTyped && !!this.shownMaskExpression) {\n        if (this.maskExpression.length !== this.shownMaskExpression.length) {\n          throw new Error('Mask expression must match mask placeholder length');\n        } else {\n          return this.shownMaskExpression;\n        }\n      } else if (this.showMaskTyped) {\n        return this.maskExpression.replace(/\\w/g, '_');\n      }\n      return '';\n    }\n    /**\n     * @return {?}\n     */\n    clearIfNotMatchFn() {\n      if (this.clearIfNotMatch === true && this.maskExpression.length !== this._formElement.value.length) {\n        this.formElementProperty = ['value', ''];\n        this.applyMask(this._formElement.value, this.maskExpression);\n      }\n    }\n    /**\n     * @param {?} __0\n     * @return {?}\n     */\n    set formElementProperty([name, value]) {\n      this._renderer.setProperty(this._formElement, name, value);\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @param {?} specialCharactersForRemove\n     * @return {?}\n     */\n    _removeMask(value, specialCharactersForRemove) {\n      return value ? value.replace(this._regExpForRemove(specialCharactersForRemove), '') : value;\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n    _removePrefix(value) {\n      if (!this.prefix) {\n        return value;\n      }\n      return value ? value.replace(this.prefix, '') : value;\n    }\n    /**\n     * @private\n     * @param {?} value\n     * @return {?}\n     */\n    _removeSufix(value) {\n      if (!this.sufix) {\n        return value;\n      }\n      return value ? value.replace(this.sufix, '') : value;\n    }\n    /**\n     * @private\n     * @param {?} specialCharactersForRemove\n     * @return {?}\n     */\n    _regExpForRemove(specialCharactersForRemove) {\n      return new RegExp(specialCharactersForRemove.map(\n      /**\n      * @param {?} item\n      * @return {?}\n      */\n      item => `\\\\${item}`).join('|'), 'gi');\n    }\n  }\n  MaskService.Éµfac = function MaskService_Factory(t) {\n    return new (t || MaskService)(Éµngcc0.ÉµÉµinject(DOCUMENT), Éµngcc0.ÉµÉµinject(config), Éµngcc0.ÉµÉµinject(Éµngcc0.ElementRef), Éµngcc0.ÉµÉµinject(Éµngcc0.Renderer2));\n  };\n  MaskService.Éµprov = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjectable({\n    token: MaskService,\n    factory: MaskService.Éµfac\n  });\n  /** @nocollapse */\n  return MaskService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet MaskDirective = /*#__PURE__*/(() => {\n  class MaskDirective {\n    /**\n     * @param {?} document\n     * @param {?} _maskService\n     */\n    constructor(document, _maskService) {\n      this.document = document;\n      this._maskService = _maskService;\n      this._position = null;\n      // tslint:disable-next-line\n      this.onChange =\n      /**\n      * @param {?} _\n      * @return {?}\n      */\n      _ => {};\n      this.onTouch =\n      /**\n      * @return {?}\n      */\n      () => {};\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set maskExpression(value) {\n      this._maskValue = value || '';\n      if (!this._maskValue) {\n        return;\n      }\n      this._maskService.maskExpression = this._repeatPatternSymbols(this._maskValue);\n      this._maskService.formElementProperty = ['value', this._maskService.applyMask(this._inputValue, this._maskService.maskExpression)];\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set specialCharacters(value) {\n      if (!value || !Array.isArray(value) || Array.isArray(value) && !value.length) {\n        return;\n      }\n      this._maskService.maskSpecialCharacters = value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set patterns(value) {\n      if (!value) {\n        return;\n      }\n      this._maskService.maskAvailablePatterns = value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set prefix(value) {\n      if (!value) {\n        return;\n      }\n      this._maskService.prefix = value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set sufix(value) {\n      if (!value) {\n        return;\n      }\n      this._maskService.sufix = value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set dropSpecialCharacters(value) {\n      this._maskService.dropSpecialCharacters = value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set showMaskTyped(value) {\n      if (!value) {\n        return;\n      }\n      this._maskService.showMaskTyped = value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set shownMaskExpression(value) {\n      if (!value) {\n        return;\n      }\n      this._maskService.shownMaskExpression = value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set showTemplate(value) {\n      this._maskService.showTemplate = value;\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    set clearIfNotMatch(value) {\n      this._maskService.clearIfNotMatch = value;\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    onInput(e) {\n      /** @type {?} */\n      const el = /** @type {?} */e.target;\n      this._inputValue = el.value;\n      if (!this._maskValue) {\n        this.onChange(el.value);\n        return;\n      }\n      /** @type {?} */\n      const position = /** @type {?} */el.selectionStart === 1 ? /** @type {?} */el.selectionStart + this._maskService.prefix.length : /** @type {?} */el.selectionStart;\n      /** @type {?} */\n      let caretShift = 0;\n      this._maskService.applyValueChanges(position,\n      /**\n      * @param {?} shift\n      * @return {?}\n      */\n      shift => caretShift = shift);\n      // only set the selection if the element is active\n      if (this.document.activeElement !== el) {\n        return;\n      }\n      el.selectionStart = el.selectionEnd = this._position !== null ? this._position : position + (\n      // tslint:disable-next-line\n      /** @type {?} */e.inputType === 'deleteContentBackward' ? 0 : caretShift);\n      this._position = null;\n    }\n    /**\n     * @return {?}\n     */\n    onBlur() {\n      this._maskService.clearIfNotMatchFn();\n      this.onTouch();\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    onFocus(e) {\n      /** @type {?} */\n      const el = /** @type {?} */e.target;\n      if (el !== null && el.selectionStart !== null && el.selectionStart === el.selectionEnd && el.selectionStart > this._maskService.prefix.length &&\n      // tslint:disable-next-line\n      /** @type {?} */e.keyCode !== 38) {\n        return;\n      }\n      if (this._maskService.showMaskTyped) {\n        this._maskService.maskIsShown = this._maskService.showMaskInInput();\n      }\n      el.value = !el.value || el.value === this._maskService.prefix ? this._maskService.prefix + this._maskService.maskIsShown : el.value;\n      /** fix of cursor position with prefix when mouse click occur */\n      if (( /** @type {?} */el.selectionStart || /** @type {?} */el.selectionEnd) <= this._maskService.prefix.length) {\n        el.selectionStart = this._maskService.prefix.length;\n        return;\n      }\n    }\n    /**\n     * @param {?} e\n     * @return {?}\n     */\n    a(e) {\n      /** @type {?} */\n      const el = /** @type {?} */e.target;\n      if (e.keyCode === 38) {\n        e.preventDefault();\n      }\n      if (e.keyCode === 37 || e.keyCode === 8) {\n        if ( /** @type {?} */el.selectionStart <= this._maskService.prefix.length && /** @type {?} */el.selectionEnd <= this._maskService.prefix.length) {\n          e.preventDefault();\n        }\n        this.onFocus(e);\n        if (e.keyCode === 8 && el.selectionStart === 0 && el.selectionEnd === el.value.length) {\n          el.value = this._maskService.prefix;\n          this._position = this._maskService.prefix ? this._maskService.prefix.length : 1;\n          this.onInput(e);\n        }\n      }\n    }\n    /**\n     * @return {?}\n     */\n    onPaste() {\n      this._position = Number.MAX_SAFE_INTEGER;\n    }\n    /**\n     * It writes the value in the input\n     * @param {?} inputValue\n     * @return {?}\n     */\n    writeValue(inputValue) {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (inputValue === undefined) {\n          inputValue = '';\n        }\n        if (typeof inputValue === 'number') {\n          inputValue = String(inputValue);\n          this._maskService.isNumberValue = true;\n        }\n        inputValue && this._maskService.maskExpression || this._maskService.maskExpression && (this._maskService.prefix || this._maskService.showMaskTyped) ? this._maskService.formElementProperty = ['value', this._maskService.applyMask(inputValue, this._maskService.maskExpression)] : this._maskService.formElementProperty = ['value', inputValue];\n        this._inputValue = inputValue;\n      });\n    }\n    // tslint:disable-next-line\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnChange(fn) {\n      this.onChange = fn;\n      this._maskService.onChange = this.onChange;\n    }\n    // tslint:disable-next-line\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    registerOnTouched(fn) {\n      this.onTouch = fn;\n    }\n    /**\n     * It disables the input element\n     * @param {?} isDisabled\n     * @return {?}\n     */\n    setDisabledState(isDisabled) {\n      this._maskService.formElementProperty = ['disabled', isDisabled];\n    }\n    /**\n     * @private\n     * @param {?} maskExp\n     * @return {?}\n     */\n    _repeatPatternSymbols(maskExp) {\n      return maskExp.match(/{[0-9]+}/) && maskExp.split('').reduce(\n      /**\n      * @param {?} accum\n      * @param {?} currval\n      * @param {?} index\n      * @return {?}\n      */\n      (accum, currval, index) => {\n        this._start = currval === '{' ? index : this._start;\n        if (currval !== '}') {\n          return this._maskService._findSpecialChar(currval) ? accum + currval : accum;\n        }\n        this._end = index;\n        /** @type {?} */\n        const repeatNumber = Number(maskExp.slice(this._start + 1, this._end));\n        /** @type {?} */\n        const repaceWith = new Array(repeatNumber + 1).join(maskExp[this._start - 1]);\n        return accum + repaceWith;\n      }, '') || maskExp;\n    }\n  }\n  MaskDirective.Éµfac = function MaskDirective_Factory(t) {\n    return new (t || MaskDirective)(Éµngcc0.ÉµÉµdirectiveInject(DOCUMENT), Éµngcc0.ÉµÉµdirectiveInject(MaskService));\n  };\n  MaskDirective.Éµdir = /*@__PURE__*/Éµngcc0.ÉµÉµdefineDirective({\n    type: MaskDirective,\n    selectors: [[\"\", \"mask\", \"\"]],\n    hostBindings: function MaskDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        Éµngcc0.ÉµÉµlistener(\"input\", function MaskDirective_input_HostBindingHandler($event) {\n          return ctx.onInput($event);\n        })(\"blur\", function MaskDirective_blur_HostBindingHandler() {\n          return ctx.onBlur();\n        })(\"click\", function MaskDirective_click_HostBindingHandler($event) {\n          return ctx.onFocus($event);\n        })(\"keydown\", function MaskDirective_keydown_HostBindingHandler($event) {\n          return ctx.a($event);\n        })(\"paste\", function MaskDirective_paste_HostBindingHandler() {\n          return ctx.onPaste();\n        });\n      }\n    },\n    inputs: {\n      maskExpression: [\"mask\", \"maskExpression\"],\n      specialCharacters: \"specialCharacters\",\n      patterns: \"patterns\",\n      prefix: \"prefix\",\n      sufix: \"sufix\",\n      dropSpecialCharacters: \"dropSpecialCharacters\",\n      showMaskTyped: \"showMaskTyped\",\n      shownMaskExpression: \"shownMaskExpression\",\n      showTemplate: \"showTemplate\",\n      clearIfNotMatch: \"clearIfNotMatch\"\n    },\n    features: [Éµngcc0.ÉµÉµProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(\n      /**\n      * @return {?}\n      */\n      () => MaskDirective),\n      multi: true\n    }, MaskService])]\n  });\n  /** @nocollapse */\n  return MaskDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet MaskPipe = /*#__PURE__*/(() => {\n  class MaskPipe {\n    /**\n     * @param {?} _maskService\n     */\n    constructor(_maskService) {\n      this._maskService = _maskService;\n    }\n    /**\n     * @param {?} value\n     * @param {?} mask\n     * @return {?}\n     */\n    transform(value, mask) {\n      if (!value) {\n        return '';\n      }\n      if (typeof mask === 'string') {\n        return this._maskService.applyMask(`${value}`, mask);\n      }\n      return this._maskService.applyMaskWithPattern(`${value}`, mask);\n    }\n  }\n  MaskPipe.Éµfac = function MaskPipe_Factory(t) {\n    return new (t || MaskPipe)(Éµngcc0.ÉµÉµdirectiveInject(MaskApplierService, 16));\n  };\n  MaskPipe.Éµpipe = /*@__PURE__*/Éµngcc0.ÉµÉµdefinePipe({\n    name: \"mask\",\n    type: MaskPipe,\n    pure: true\n  });\n  /** @nocollapse */\n  return MaskPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nlet NgxMaskModule = /*#__PURE__*/(() => {\n  class NgxMaskModule {\n    /**\n     * @param {?=} configValue\n     * @return {?}\n     */\n    static forRoot(configValue) {\n      return {\n        ngModule: NgxMaskModule,\n        providers: [{\n          provide: NEW_CONFIG,\n          useValue: configValue\n        }, {\n          provide: INITIAL_CONFIG,\n          useValue: initialConfig\n        }, {\n          provide: config,\n          useFactory: _configFactory,\n          deps: [INITIAL_CONFIG, NEW_CONFIG]\n        }]\n      };\n    }\n    /**\n     * @param {?=} _configValue\n     * @return {?}\n     */\n    static forChild(_configValue) {\n      return {\n        ngModule: NgxMaskModule\n      };\n    }\n  }\n  NgxMaskModule.Éµfac = function NgxMaskModule_Factory(t) {\n    return new (t || NgxMaskModule)();\n  };\n  NgxMaskModule.Éµmod = /*@__PURE__*/Éµngcc0.ÉµÉµdefineNgModule({\n    type: NgxMaskModule\n  });\n  NgxMaskModule.Éµinj = /*@__PURE__*/Éµngcc0.ÉµÉµdefineInjector({\n    providers: [MaskApplierService]\n  });\n  return NgxMaskModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && Éµngcc0.ÉµÉµsetNgModuleScope(NgxMaskModule, {\n    declarations: [MaskDirective, MaskPipe],\n    exports: [MaskDirective, MaskPipe]\n  });\n})();\n/**\n * \\@internal\n * @param {?} initConfig\n * @param {?} configValue\n * @return {?}\n */\nfunction _configFactory(initConfig, configValue) {\n  return typeof configValue === 'function' ? configValue() : Object.assign({}, initConfig, configValue);\n}\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { config, NEW_CONFIG, INITIAL_CONFIG, initialConfig, MaskDirective, MaskService, _configFactory, NgxMaskModule, MaskPipe, MaskApplierService as Éµa };\n\n//# sourceMappingURL=ngx-mask.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}